load("@bazel_tools//tools/build_defs/repo:git_worker.bzl", "git_repo")
load(
    "@bazel_tools//tools/build_defs/repo:utils.bzl",
    "get_auth",
    "patch",
    "update_attrs",
    "workspace_and_buildfile",
)

_attrs = {
        "remote": attr.string(
            mandatory = True,
            doc = "The URI of the remote Git repository",
        ),
        "commit": attr.string(
            default = "",
            doc =
                "specific commit to be checked out." +
                " Precisely one of branch, tag, or commit must be specified.",
        ),
        "shallow_since": attr.string(
            default = "",
            doc =
                "an optional date, not after the specified commit; the argument " +
                "is not allowed if a tag or branch is specified (which can " +
                "always be cloned with --depth=1). Setting such a date close to " +
                "the specified commit may allow for a shallow clone of the " +
                "repository even if the server does not support shallow fetches " +
                "of arbitrary commits. Due to bugs in git's --shallow-since " +
                "implementation, using this attribute is not recommended as it " +
                "may result in fetch failures.",

        ),
        "tag": attr.string(

            default = "",
            doc =
                "tag in the remote repository to checked out." +
                " Precisely one of branch, tag, or commit must be specified.",
        ),
        "branch": attr.string(
            default = "",
            doc =
                "branch in the remote repository to checked out." +
                " Precisely one of branch, tag, or commit must be specified.",
        ),
        "init_submodules": attr.bool(
            default = False,
            doc = "Whether to clone submodules in the repository.",
        ),
        "recursive_init_submodules": attr.bool(
            default = False,
            doc = "Whether to clone submodules recursively in the repository.",
        ),
        "verbose": attr.bool(default = False),
        "strip_prefix": attr.string(
            default = "",
            doc = "A directory prefix to strip from the extracted files.",

        ),
        "patches": attr.label_list(
            default = [],
            doc =
                "A list of files that are to be applied as patches after " +

                "extracting the archive. By default, it uses the Bazel-native patch implementation " +
                "which doesn't support fuzz match and binary patch, but Bazel will fall back to use " +
                "patch command line tool if `patch_tool` attribute is specified or there are " +
                "arguments other than `-p` in `patch_args` attribute.",
        ),
        "patch_tool": attr.string(

            default = "",
            doc = "The patch(1) utility to use. If this is specified, Bazel will use the specified " +
                  "patch tool instead of the Bazel-native patch implementation.",
        ),
        "patch_args": attr.string_list(

            default = [],

            doc =
                "The arguments given to the patch tool. Defaults to -p0 (see the `patch_strip` " +

                "attribute), however -p1 will usually be needed for patches generated by " +
                "git. If multiple -p arguments are specified, the last one will take effect." +
                "If arguments other than -p are specified, Bazel will fall back to use patch " +
                "command line tool instead of the Bazel-native patch implementation. When falling " +
                "back to patch command line tool and patch_tool attribute is not specified, " +

                "`patch` will be used.",
        ),
        "patch_strip": attr.int(
            default = 0,
            doc = "When set to `N`, this is equivalent to inserting `-pN` to the beginning of `patch_args`.",

        ),
        "patch_cmds": attr.string_list(
            default = [],
            doc = "Sequence of Bash commands to be applied on Linux/Macos after patches are applied.",
        ),
        "patch_cmds_win": attr.string_list(
            default = [],
            doc = "Sequence of Powershell commands to be applied on Windows after patches are " +
                  "applied. If this attribute is not set, patch_cmds will be executed on Windows, " +
                  "which requires Bash binary to exist.",
        ),
        "remote_module_file_urls": attr.string_list(
            default = [],
            doc = "For internal use only.",
        ),
        "remote_module_file_integrity": attr.string(
            default = "",
            doc = "For internal use only.",
        ),
        "build_file": attr.label(
            allow_single_file = True,
            doc =
                "The file to use as the BUILD file for this repository." +
                "This attribute is an absolute label (use '@//' for the main " +
                "repo). The file does not need to be named BUILD, but can " +
                "be (something like BUILD.new-repo-name may work well for " +
                "distinguishing it from the repository's actual BUILD files. ",
        ),
        "build_file_content": attr.string(
            doc =
                "The content for the BUILD file for this repository. ",

        ),
        "workspace_file": attr.label(
            doc = "No-op attribute; do not use.",
        ),

        "workspace_file_content": attr.string(
            doc = "No-op attribute; do not use.",
        ),
        "sparse_checkout_patterns": attr.string_list(
            default = [],
            doc = "Sequence of patterns for a sparse checkout of files in this repository.",
        ),
        "sparse_checkout_file": attr.label(
            doc =
                "File containing .gitignore-style patterns for a sparse checkout of files " +
                "in this repository. Either `sparse_checkout_patterns` or `sparse_checkout_file` " +
                "may be specified, or neither, but not both.",
        ),
        "path": attr.string(
            doc =
                "The path to the directory to make available as a repo.\n\nThe path can be " +
                "either absolute, or relative to the workspace root.",
            mandatory = True,
        ),
        "path_prefix_env": attr.string(
            doc = "The path prefix environment variable.",
            mandatory = False,
        ),
    }


def _clone_or_update_repo(rctx):
    if ((not rctx.attr.tag and not rctx.attr.commit and not rctx.attr.branch) or
        (rctx.attr.tag and rctx.attr.commit) or
        (rctx.attr.tag and rctx.attr.branch) or
        (rctx.attr.commit and rctx.attr.branch)):
        fail("Exactly one of commit, tag, or branch must be provided")
    root = rctx.path(".")
    directory = str(root)
    if rctx.attr.strip_prefix:
        directory = root.get_child(".tmp_git_root")
    git_ = git_repo(rctx, directory)
    if rctx.attr.strip_prefix:
        dest_link = "{}/{}".format(directory, rctx.attr.strip_prefix)
        if not rctx.path(dest_link).exists:
            fail("strip_prefix at {} does not exist in repo".format(rctx.attr.strip_prefix))
        for item in rctx.path(dest_link).readdir():
            rctx.symlink(item, root.get_child(item.basename))
    if rctx.attr.shallow_since:
        return {"commit": git_.commit, "shallow_since": git_.shallow_since}
    else:

        return {"commit": git_.commit}

def _update_git_attrs(orig, keys, override):
    result = update_attrs(orig, keys, override)
    # if we found the actual commit, remove all other means of specifying it,
    # like tag or branch.
    if "commit" in result:
        result.pop("tag", None)
        result.pop("branch", None)

    return result

def _git_repository_impl(rctx):
    if rctx.attr.build_file and rctx.attr.build_file_content:
        fail("Only one of build_file and build_file_content can be provided.")

    if rctx.attr.sparse_checkout_patterns and rctx.attr.sparse_checkout_file:
        fail("Only one of sparse_checkout_patterns and sparse_checkout_file can be provided.")

    update = _clone_or_update_repo(rctx)
    workspace_and_buildfile(rctx)
    patch(rctx)
    # Download the module file after applying patches since modules may decide
    # to patch their packaged module and the patch may not apply to the file
    # checked in to the registry. This overrides the file if it exists.
    if rctx.attr.remote_module_file_urls:
        rctx.download(
            rctx.attr.remote_module_file_urls,
            "MODULE.bazel",
            auth = get_auth(rctx, rctx.attr.remote_module_file_urls),
            integrity = rctx.attr.remote_module_file_integrity,
        )
    if rctx.attr.strip_prefix:
        rctx.delete(rctx.path(".tmp_git_root/.git"))
    else:
        rctx.delete(rctx.path(".git"))

    return _update_git_attrs(rctx.attr, _attrs.keys(), update)

def _local_or_git_repository_impl(rctx):
    path = rctx.attr.path
    if rctx.attr.path_prefix_env:
        path_prefix = rctx.os.environ.get(rctx.attr.path_prefix_env, "")
        if not path_prefix.endswith("/"):
            path_prefix += "/"
        path = path_prefix + path
    path = rctx.workspace_root.get_child(path)
    if not path.is_dir:
        _git_repository_impl(rctx)
    else:
        rctx.watch(path)
        rctx.symlink(path, ".")

local_or_git_repository = repository_rule(
    implementation = _local_or_git_repository_impl,
    attrs = _attrs,
    doc =
        "Makes a local directory that already contains Bazel files available as a repo. This " +
        "directory should contain Bazel BUILD files and a repo boundary file already.",
    local = True,
)
